<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ModulTick</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="/icon-192x192.png">
    <link rel="manifest" href="/manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Main Display */
        .display-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .time-display {
            font-size: clamp(60px, 15vw, 120px);
            font-weight: 200;
            font-variant-numeric: tabular-nums;
            letter-spacing: -0.02em;
            text-align: center;
            min-width: 300px;
        }

        .milliseconds {
            font-size: 0.7em;
            opacity: 0.9;
        }

        /* Laps Container */
        .laps-container {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 0 30px;
            margin-bottom: 20px;
        }

        .lap-item {
            display: flex;
            justify-content: space-between;
            padding: 15px 0;
            border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
            font-size: 18px;
            font-weight: 300;
        }

        .lap-number {
            opacity: 0.6;
        }

        .lap-time {
            font-variant-numeric: tabular-nums;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: space-around;
            padding: 20px 30px 40px;
            gap: 20px;
        }

        .control-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid;
            background: transparent;
            color: inherit;
            font-size: 16px;
            font-weight: 400;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* Button States */
        .btn-start {
            border-color: #30d158;
            color: #30d158;
        }

        .btn-start:active {
            background: rgba(48, 209, 88, 0.1);
        }

        .btn-stop {
            border-color: #ff3b30;
            color: #ff3b30;
        }

        .btn-stop:active {
            background: rgba(255, 59, 48, 0.1);
        }

        .btn-lap {
            border-color: #fff;
            color: #fff;
        }

        .btn-lap:active {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-reset {
            border-color: #8e8e93;
            color: #8e8e93;
        }

        .btn-reset:active {
            background: rgba(142, 142, 147, 0.1);
        }

        /* Hidden UI Elements */
        .hidden-ui {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }

        .hidden-ui.active {
            display: block;
        }

        .hidden-ui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .hidden-ui h2 {
            font-size: 24px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            color: #007aff;
            font-size: 18px;
            cursor: pointer;
            padding: 10px;
        }

        /* Input Fields */
        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            opacity: 0.8;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
        }

        .input-group input:focus {
            outline: none;
            border-color: #007aff;
            background: rgba(255, 255, 255, 0.15);
        }

        /* Force Type Buttons */
        .force-type-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .force-type-btn {
            flex: 1;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .force-type-btn.active {
            background: #007aff;
            border-color: #007aff;
        }

        /* Sequence Display */
        .sequence-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .sequence-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sequence-item:last-child {
            border-bottom: none;
        }

        .remove-sequence-btn {
            background: none;
            border: none;
            color: #ff3b30;
            cursor: pointer;
            padding: 5px;
        }

        /* Action Buttons */
        .action-btn {
            width: 100%;
            padding: 15px;
            background: #007aff;
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 18px;
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.2s;
        }

        .action-btn:active {
            transform: scale(0.98);
            background: #0051d5;
        }

        .action-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Presets List */
        .presets-list {
            margin-top: 20px;
        }

        .preset-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-item:active {
            background: rgba(255, 255, 255, 0.1);
        }

        .preset-name {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .preset-info {
            font-size: 14px;
            opacity: 0.7;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 122, 255, 0.9);
            color: #fff;
            padding: 15px 20px;
            border-radius: 8px;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 2000;
        }

        .notification.show {
            transform: translateX(0);
        }
    </style>
</head>
<body>
    <!-- Main Display -->
    <div class="display-container">
        <div class="time-display" id="timeDisplay">
            <span id="minutes">00</span>:<span id="seconds">00</span><span class="milliseconds">,<span id="milliseconds">00</span></span>
        </div>
    </div>

    <!-- Laps -->
    <div class="laps-container" id="lapsContainer"></div>

    <!-- Controls -->
    <div class="controls">
        <button class="control-btn btn-reset" id="lapResetBtn">Löschen</button>
        <button class="control-btn btn-start" id="startStopBtn">Start</button>
    </div>

    <!-- Manual Input UI -->
    <div class="hidden-ui" id="manualInputUI">
        <div class="hidden-ui-header">
            <h2>Manuelle Eingabe</h2>
            <button class="close-btn" onclick="hideManualInput()">Schließen</button>
        </div>
        
        <div class="input-group">
            <label>Wert eingeben:</label>
            <input type="number" id="manualInputValue" placeholder="z.B. 42">
        </div>

        <button class="action-btn secondary" onclick="addToSequence()">Zur Sequenz hinzufügen</button>

        <div class="sequence-display" id="sequenceDisplay">
            <p style="opacity: 0.6; text-align: center;">Keine Werte in der Sequenz</p>
        </div>

        <div class="force-type-buttons">
            <button class="force-type-btn active" data-type="ms">MS</button>
            <button class="force-type-btn" data-type="s">Summe</button>
            <button class="force-type-btn" data-type="ft">FT</button>
        </div>

        <button class="action-btn" onclick="startManualForce()">Force starten</button>
    </div>

    <!-- Presets Selection UI -->
    <div class="hidden-ui" id="presetsUI">
        <div class="hidden-ui-header">
            <h2>Voreinstellungen auswählen</h2>
            <button class="close-btn" onclick="hidePresets()">Schließen</button>
        </div>

        <div class="presets-list" id="presetsList"></div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // Global Variables
        let startTime = 0;
        let elapsedTime = 0;
        let timerInterval = null;
        let isRunning = false;
        let laps = [];
        let lapStartTime = 0;
        let currentLapTime = 0;
        
        // Force Variables
        let activeForces = [];
        let manualSequence = [];
        let selectedForceType = 'ms';
        let presets = [];
        
        // Tracking Variables
        let stopCount = 0;
        let lapCount = 0;
        let resetCount = 0;
        let sessionStartTime = Date.now();
        
        // Triple Click Detection
        let clickCount = 0;
        let clickTimer = null;

        // DOM Elements
        const timeDisplay = document.getElementById('timeDisplay');
        const minutesEl = document.getElementById('minutes');
        const secondsEl = document.getElementById('seconds');
        const millisecondsEl = document.getElementById('milliseconds');
        const startStopBtn = document.getElementById('startStopBtn');
        const lapResetBtn = document.getElementById('lapResetBtn');
        const lapsContainer = document.getElementById('lapsContainer');

        // Initialize
        async function init() {
            updateDisplay(0);
            setupEventListeners();
            
            // Get token from URL
            const urlParams = new URLSearchParams(window.location.search);
            window.token = urlParams.get('token');
            
            if (window.token) {
                // Load presets
                await loadPresets();
                // Start polling for forces
                setInterval(checkForces, 400);
            }
        }

        // Event Listeners
        function setupEventListeners() {
            startStopBtn.addEventListener('click', handleStartStop);
            lapResetBtn.addEventListener('click', handleLapReset);
            
            // Triple click on display for manual input
            timeDisplay.addEventListener('click', handleTripleClick);
            
            // Triple click on lap/reset button for presets
            lapResetBtn.addEventListener('click', (e) => {
                if (e.detail === 3) {
                    showPresets();
                }
            });

            // Force type buttons
            document.querySelectorAll('.force-type-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.force-type-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    selectedForceType = e.target.dataset.type;
                });
            });
        }

        // Triple Click Handler
        function handleTripleClick() {
            clickCount++;
            
            if (clickCount === 3) {
                showManualInput();
                clickCount = 0;
                clearTimeout(clickTimer);
            } else {
                clearTimeout(clickTimer);
                clickTimer = setTimeout(() => {
                    clickCount = 0;
                }, 500);
            }
        }

        // Stopwatch Functions
        function handleStartStop() {
            if (isRunning) {
                stop();
            } else {
                start();
            }
        }

        function handleLapReset() {
            if (isRunning) {
                lap();
            } else {
                reset();
            }
        }

        function start() {
            if (!isRunning) {
                startTime = Date.now() - elapsedTime;
                lapStartTime = Date.now() - currentLapTime;
                timerInterval = setInterval(updateTimer, 10);
                isRunning = true;
                
                startStopBtn.textContent = 'Stop';
                startStopBtn.classList.remove('btn-start');
                startStopBtn.classList.add('btn-stop');
                
                lapResetBtn.textContent = 'Runde';
                lapResetBtn.classList.remove('btn-reset');
                lapResetBtn.classList.add('btn-lap');
            }
        }

        function stop() {
            if (isRunning) {
                clearInterval(timerInterval);
                isRunning = false;
                stopCount++;
                
                // Check for forces
                const forcedTime = checkForceConditions('stop', elapsedTime);
                if (forcedTime !== null) {
                    elapsedTime = forcedTime;
                    currentLapTime = forcedTime - (elapsedTime - currentLapTime);
                    updateDisplay(elapsedTime);
                    updateCurrentLap();
                }
                
                startStopBtn.textContent = 'Weiter';
                startStopBtn.classList.add('btn-start');
                startStopBtn.classList.remove('btn-stop');
                
                lapResetBtn.textContent = 'Löschen';
                lapResetBtn.classList.add('btn-reset');
                lapResetBtn.classList.remove('btn-lap');
            }
        }

        function lap() {
            if (isRunning) {
                lapCount++;
                
                // Check for forces on the lap time
                const forcedTime = checkForceConditions('lap', currentLapTime);
                const displayTime = forcedTime !== null ? forcedTime : currentLapTime;
                
                laps.unshift({
                    number: laps.length + 1,
                    time: displayTime
                });
                
                currentLapTime = 0;
                lapStartTime = Date.now();
                updateLapsDisplay();
            }
        }

        function reset() {
            clearInterval(timerInterval);
            isRunning = false;
            elapsedTime = 0;
            currentLapTime = 0;
            laps = [];
            resetCount++;
            
            updateDisplay(0);
            updateLapsDisplay();
            
            startStopBtn.textContent = 'Start';
            startStopBtn.classList.add('btn-start');
            startStopBtn.classList.remove('btn-stop');
            
            lapResetBtn.textContent = 'Löschen';
            lapResetBtn.classList.add('btn-reset');
            lapResetBtn.classList.remove('btn-lap');
        }

        function updateTimer() {
            elapsedTime = Date.now() - startTime;
            currentLapTime = Date.now() - lapStartTime;
            updateDisplay(elapsedTime);
            updateCurrentLap();
        }

        function updateDisplay(time) {
            const totalSeconds = Math.floor(time / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = Math.floor((time % 1000) / 10);
            
            minutesEl.textContent = String(minutes).padStart(2, '0');
            secondsEl.textContent = String(seconds).padStart(2, '0');
            millisecondsEl.textContent = String(milliseconds).padStart(2, '0');
        }

        function updateCurrentLap() {
            if (isRunning && laps.length === 0) {
                // Update first lap in display
                const lapItem = document.querySelector('.lap-item.current');
                if (lapItem) {
                    const time = formatTime(currentLapTime);
                    lapItem.querySelector('.lap-time').textContent = time;
                }
            }
        }

        function updateLapsDisplay() {
            lapsContainer.innerHTML = '';
            
            // Add current lap if running
            if (isRunning || laps.length > 0) {
                const currentLapEl = document.createElement('div');
                currentLapEl.className = 'lap-item current';
                currentLapEl.innerHTML = `
                    <span class="lap-number">Runde ${laps.length + 1}</span>
                    <span class="lap-time">${formatTime(currentLapTime)}</span>
                `;
                lapsContainer.appendChild(currentLapEl);
            }
            
            // Add completed laps
            laps.forEach(lap => {
                const lapEl = document.createElement('div');
                lapEl.className = 'lap-item';
                lapEl.innerHTML = `
                    <span class="lap-number">Runde ${lap.number}</span>
                    <span class="lap-time">${formatTime(lap.time)}</span>
                `;
                lapsContainer.appendChild(lapEl);
            });
        }

        function formatTime(time) {
            const totalSeconds = Math.floor(time / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = Math.floor((time % 1000) / 10);
            
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')},${String(milliseconds).padStart(2, '0')}`;
        }

        // Force Functions
        function checkForceConditions(trigger, currentTime) {
            // Check manual sequence
            if (manualSequence.length > 0) {
                const force = manualSequence.shift();
                updateSequenceDisplay();
                return applyForce(force.type, force.value, currentTime);
            }
            
            // Check active forces
            for (let i = 0; i < activeForces.length; i++) {
                const force = activeForces[i];
                
                // Check trigger
                if (force.trigger !== 'both' && force.trigger !== trigger) {
                    continue;
                }
                
                // Check conditions
                if (force.conditions && !checkConditions(force.conditions)) {
                    continue;
                }
                
                // Apply force
                activeForces.splice(i, 1);
                return applyForce(force.type, force.value, currentTime);
            }
            
            return null;
        }

        function checkConditions(conditions) {
            if (!conditions || conditions.type === 'none') return true;
            
            const elapsed = Date.now() - sessionStartTime;
            
            switch (conditions.type) {
                case 'seconds':
                    return elapsed >= conditions.value * 1000;
                case 'stops':
                    return stopCount >= conditions.value;
                case 'laps':
                    return lapCount >= conditions.value;
                case 'resets':
                    return resetCount >= conditions.value;
                default:
                    return true;
            }
        }

        function applyForce(type, value, currentTime) {
            const totalSeconds = Math.floor(currentTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            
            switch (type) {
                case 'ms':
                    // MS-Force: Set specific milliseconds
                    return (minutes * 60 + seconds) * 1000 + (value * 10);
                    
                case 's':
                    // S-Force (Sum): Calculate sum and set as milliseconds
                    const sum = calculateTimeSum(minutes, seconds);
                    if (sum <= 99 && sum == value) {
                        return (minutes * 60 + seconds) * 1000 + (value * 10);
                    }
                    return null;
                    
                case 'ft':
                    // FT-Force: Set full time
                    const ftMinutes = Math.floor(value / 100);
                    const ftSeconds = value % 100;
                    if (ftSeconds < 60) {
                        return (ftMinutes * 60 + ftSeconds) * 1000;
                    }
                    return null;
                    
                default:
                    return null;
            }
        }

        function calculateTimeSum(minutes, seconds) {
            const digits = String(minutes).padStart(2, '0') + String(seconds).padStart(2, '0');
            return digits.split('').reduce((sum, digit) => sum + parseInt(digit), 0);
        }

        // Manual Input Functions
        function showManualInput() {
            document.getElementById('manualInputUI').classList.add('active');
            document.getElementById('manualInputValue').value = '';
            manualSequence = [];
            updateSequenceDisplay();
        }

        function hideManualInput() {
            document.getElementById('manualInputUI').classList.remove('active');
        }

        function addToSequence() {
            const value = parseInt(document.getElementById('manualInputValue').value);
            if (!isNaN(value)) {
                manualSequence.push({
                    type: selectedForceType,
                    value: value
                });
                document.getElementById('manualInputValue').value = '';
                updateSequenceDisplay();
            }
        }

        function updateSequenceDisplay() {
            const display = document.getElementById('sequenceDisplay');
            
            if (manualSequence.length === 0) {
                display.innerHTML = '<p style="opacity: 0.6; text-align: center;">Keine Werte in der Sequenz</p>';
            } else {
                display.innerHTML = manualSequence.map((item, index) => `
                    <div class="sequence-item">
                        <span>${item.type.toUpperCase()}: ${item.value}</span>
                        <button class="remove-sequence-btn" onclick="removeFromSequence(${index})">✕</button>
                    </div>
                `).join('');
            }
        }

        function removeFromSequence(index) {
            manualSequence.splice(index, 1);
            updateSequenceDisplay();
        }

        function startManualForce() {
            if (manualSequence.length > 0) {
                hideManualInput();
                showNotification('Manuelle Force-Sequenz aktiviert');
            }
        }

        // Preset Functions
        function showPresets() {
            document.getElementById('presetsUI').classList.add('active');
            displayPresets();
        }

        function hidePresets() {
            document.getElementById('presetsUI').classList.remove('active');
        }

        async function loadPresets() {
            if (!window.token) return;
            
            try {
                const response = await fetch(`/api/presets/${window.token}`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    presets = await response.json();
                }
            } catch (error) {
                console.error('Error loading presets:', error);
            }
        }

        function displayPresets() {
            const list = document.getElementById('presetsList');
            
            if (presets.length === 0) {
                list.innerHTML = '<p style="opacity: 0.6; text-align: center;">Keine Voreinstellungen verfügbar</p>';
            } else {
                list.innerHTML = presets.map(preset => `
                    <div class="preset-item" onclick="activatePreset('${preset.name}')">
                        <div class="preset-name">${preset.name}</div>
                        <div class="preset-info">
                            ${preset.force_type.toUpperCase()} - ${preset.force_sequence.length} Werte
                            ${preset.conditions ? ` - Bedingung: ${preset.conditions.value} ${preset.conditions.type}` : ''}
                        </div>
                    </div>
                `).join('');
            }
        }

        async function activatePreset(name) {
            const preset = presets.find(p => p.name === name);
            if (preset) {
                // Convert preset to active forces
                preset.force_sequence.forEach(value => {
                    activeForces.push({
                        type: preset.force_type,
                        value: value,
                        trigger: preset.trigger || 'both',
                        conditions: preset.conditions
                    });
                });
                
                hidePresets();
                showNotification(`Voreinstellung "${name}" aktiviert`);
            }
        }

        // API Force Checking
        async function checkForces() {
            if (!window.token) return;
            
            try {
                const response = await fetch(`/api/data/${window.token}`);
                if (response.ok) {
                    const forces = await response.json();
                    
                    for (const force of forces) {
                        if (force.app === 'stopwatch' || force.app === 'modultick') {
                            activeForces.push({
                                id: force.forceId,
                                type: force.mode || force.force_type || 'ms',
                                value: force.target || force.value,
                                trigger: force.trigger || 'both',
                                conditions: force.conditions
                            });
                            
                            // Acknowledge force
                            await fetch(`/api/ack/${window.token}`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ forceId: force.forceId })
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking forces:', error);
            }
        }

        // Helper Functions
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.background = type === 'error' ? 'rgba(255, 59, 48, 0.9)' : 'rgba(0, 122, 255, 0.9)';
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Initialize
        init();
    </script>
</body>
</html>